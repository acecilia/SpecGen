import Foundation
import CarthageKit

class Carthage {
    static let carthageVersionRegex = try! NSRegularExpression(pattern: "\\d+(\\.\\d+){0,2}")
    static let carthageCocoaPodsEndgameKey = "cocoapodsendgame"
    static let carthageCocoaPodsAutogeneratedPodsSeparator = "# \(carthageCocoaPodsEndgameKey):autogeneratedpods"
    static let carthageCocoaPodsFrameworksRegex = try! NSRegularExpression(pattern: "# \(carthageCocoaPodsEndgameKey):frameworks:(.*)")

    private let carthageDependencies: [CarthageInfo]

    init(_ cartfilePath: URL, _ resolvedCartfilePath: URL) throws {
        let carthageFrameworks = try Carthage.getFrameworks(cartfilePath)
        self.carthageDependencies = try Carthage.setVersion(resolvedCartfilePath, carthageFrameworks)
    }

    func fixversion(_ frameworksInfo: [FrameworkInfo]) throws -> [FrameworkInfo] {
        let fixedFrameworksInfo: [FrameworkInfo] = frameworksInfo.map { frameworkInfo in
            guard let matchingIndex = carthageDependencies.firstIndex(where: { $0.name == frameworkInfo.name }) else {
                fatalError()
            }
            return FrameworkInfo(name: frameworkInfo.name, version: carthageDependencies[matchingIndex].version)
        }

        return fixedFrameworksInfo
    }

    func filter(_ frameworksInfo: [FrameworkInfo]) throws -> [FrameworkInfo] {
        return frameworksInfo.filter { frameworkInfo in
            carthageDependencies.contains { $0.name == frameworkInfo.name }
        }
    }

    private static func getFrameworks(_ cartfilePath: URL) throws -> [CarthageFramework] {
        let cartfileContent = try String(contentsOf: cartfilePath)
        let splitCartfile = cartfileContent.spm_split(around: Carthage.carthageCocoaPodsAutogeneratedPodsSeparator)
        let cartfileFilteredContent = splitCartfile.1 ?? cartfileContent

        let cartfileLines = cartfileFilteredContent.components(separatedBy: .newlines)
        let explicitFrameworkMappings: [CarthageFramework] = try cartfileLines.compactMap { line in
            guard let cartfile = Cartfile.from(string: line).value else {
                throw Error.cartfileCouldNotBeRed(cartfilePath: cartfilePath)
            }
            guard let dependency = cartfile.dependencies.first else {
                // This is not a line containing a dependency
                return nil
            }

            let explicitFrameworks = Carthage.carthageCocoaPodsFrameworksRegex
                .groupMatches(in: line)
                .flatMap { $0.flatMap { $0.components(separatedBy: .whitespaces) } }

            if explicitFrameworks.isEmpty {
                return CarthageFramework(name: dependency.key.name, explicitFrameworks: [])
            } else {
                return CarthageFramework(name: dependency.key.name, explicitFrameworks: explicitFrameworks)
            }
        }
        return explicitFrameworkMappings
    }

    private static func setVersion(_ resolvedCartfilePath: URL, _ frameworks: [CarthageFramework]) throws -> [CarthageInfo] {
        let resolvedCartfileContent = try String(contentsOf: resolvedCartfilePath)
        guard let resolvedCartfile = ResolvedCartfile.from(string: resolvedCartfileContent).value else {
            throw Error.resolvedCartfileCouldNotBeRed(resolvedCartfilePath: resolvedCartfilePath)
        }

        let carthageInfo: [CarthageInfo] = frameworks.compactMap { framework -> [CarthageInfo] in
            guard let dependency = resolvedCartfile.dependencies.first(where: { $0.key.name == framework.name }) else {
                fatalError()
            }

            let carthageVersionString = dependency.value.description
            // Carthage versions return the tag name, which in some cases is not exacly following semantic versioning,
            // and may follow the pattern 'v1.2.3'. A simple regex should fix this issue
            guard let parsedVersion = Carthage.carthageVersionRegex.firstMatch(in: carthageVersionString) else {
                fatalError()
            }

            if framework.explicitFrameworks.isEmpty {
                return [CarthageInfo(name: dependency.key.name, version: parsedVersion)]
            } else {
                return framework.explicitFrameworks.map {
                    CarthageInfo(name: $0, version: parsedVersion)
                }
            }
        }.flatMap { $0 }

        return carthageInfo
    }
}

private struct CarthageFramework {
    let name: String
    let explicitFrameworks: [String]
}
